import functions_framework
from flask import jsonify, request
from reportlab.lib.pagesizes import letter
from reportlab.lib.units import mm
from reportlab.pdfgen import canvas
from reportlab.lib.colors import HexColor
import dropbox
import os
import io
from datetime import datetime
import base64
from PIL import Image
import json

# Dropbox access token
DROPBOX_ACCESS_TOKEN = os.environ.get('DROPBOX_ACCESS_TOKEN', 'sl.u.AGRXhHpIz_mJt0rkOdZChiiAS01VO_-GaqfLe1CYLYX8Nc2YFtrYpSAIFVpZ5lZ0v1q8GHBXTxQ79Dopgo1gH99TSYFgME-UdHy20GB4bERMqsnsoiYelKx0JU0Vo7Rekv1QXJd4X-COfnZesoSqstS_H9lFiHPfSk76hqhWuqUQk4uQ1iPtOFHeh4B00g3bB3h148It3kmKUTS4Eta5OM75imAnj8DdHhTjeCrJXA2B3pLuVs97hMrpEUqIku0ofEXfvRp4pB67gWumGoMcKMfsaYU2JJfZr85x9ZyQbvyv64cT_B3R9_98sDyIGkWBhheyvhmuxehkt4m9PQKVzDfZKmooWt7nVzXbmdgV3B8W76843wLbpgvXDlmdk2DLHvqi4NoAK7oojynEdC_KrYQtvlILCh-FmZCRv3k6mfpoKI7pUBBY1i2QXi9HGKU9Heu8yv03BZCdwgEceVWqsqpLF5glDVQWswNukYj-HYUL1y7Dna5wsEUT-6BsiO14JjkBFybotdYXQcWIaCF1tIgkysQBrxBefOd7RLGs3hGWnTlinLv92f6Ea74U2qBwtwzuYRoTAkfbsmNyj3LLUsx7rErCIaVoMwvCkSA3eKGVCV9p7u-P8AwTOuLVYYtDK2XuB-IHYpjXC4g4xyn2x5nH2IHUcphcVzZdzfDXF0BmqNlTPNEDnOzqSMXe1HiwXjsZLftBtEc92w7EPHwQewhA8ZmUn70EVSso0y2f4EOhP_R-Dujoyq038p_nr3lTQa9s7oDdiBge4tSGU58KIMPoi8q-t0TbQ5OmXKB5-fjSX7yECJe0ZsgsQ-iqZcAC1RNEGw-ZbHqI5XF1LW5tlRI86OzuDH0b6Cerg8LlEoyRjZU8tiPjmhKdhYqix_ZV56YNRqSSOU_pIclLYGG3IqMZm1xLTFkRLzGZRTK_hQm1IFwFs1v2CgUIdZgLmElzwQBsXIT9YNiMqX1fPeZW_UB9ZgxpIQZm7ku-Ous3ChIzFLzHA2EWptki1c9DbXJd_swUZxFreM1j8mZB0ZpfRi3KpYqdt6lCV-Abhdn5fGwJ0G71y3ATLYQb6gYhc_K3RldoubBd0AAoLhWbW3R27YWMbsgQG9XXc72OrRPjO0U_dLBnL65NoreYFuYe0WqreT_B53N3RCrWVcOdX5rGb16ru_6D_nUDIf22xKAodKpD6R17tmZ8H7vSaWOMtksflAyJVuIOVKtQhvsJhnDG-ws0puqQDVJ4-7aOrl6pEYR6cpu-gVPwqXxNJvSr3xYSqWvTMzsUu3bHwEdJhIqYFJyh')

# Colors matching PCMS branding
NAVY = HexColor('#1e3a5f')
GOLD = HexColor('#d4a84b')
TEAL = HexColor('#2d8b9f')

def fix_image_orientation(image_data):
    """Fix image orientation based on EXIF data"""
    try:
        img = Image.open(io.BytesIO(base64.b64decode(image_data.split(',')[1] if ',' in image_data else image_data)))
        
        # Check for EXIF orientation
        try:
            from PIL import ExifTags
            for orientation in ExifTags.TAGS.keys():
                if ExifTags.TAGS[orientation] == 'Orientation':
                    break
            
            exif = img._getexif()
            if exif is not None:
                orientation_value = exif.get(orientation)
                if orientation_value == 3:
                    img = img.rotate(180, expand=True)
                elif orientation_value == 6:
                    img = img.rotate(270, expand=True)
                elif orientation_value == 8:
                    img = img.rotate(90, expand=True)
        except (AttributeError, KeyError, IndexError):
            pass
        
        # Convert back to bytes
        output = io.BytesIO()
        img.save(output, format='JPEG', quality=85)
        output.seek(0)
        return output
    except Exception as e:
        print(f"Error fixing orientation: {e}")
        # Return original if processing fails
        return io.BytesIO(base64.b64decode(image_data.split(',')[1] if ',' in image_data else image_data))

@functions_framework.http
def generate_certificate(request):
    # Handle CORS
    if request.method == 'OPTIONS':
        headers = {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'POST',
            'Access-Control-Allow-Headers': 'Content-Type',
            'Access-Control-Max-Age': '3600'
        }
        return ('', 204, headers)
    
    headers = {'Access-Control-Allow-Origin': '*'}
    
    try:
        data = request.get_json()
        
        # Extract test data
        customer = data.get('customer', 'Unknown Customer')
        location = data.get('location', 'Unknown Location')
        serial_number = data.get('serialNumber', 'N/A')
        manufacturer = data.get('manufacturer', 'N/A')
        service_type = data.get('serviceType', 'Closed Pipe')
        is_startup = data.get('isStartup', False)
        water_type = data.get('waterType', '')
        meter_reading = data.get('meterReading', '')
        calibration = data.get('calibration', '')
        programming = data.get('programming', '')
        notes = data.get('notes', '')
        tech_notes = data.get('techNotes', '')  # Internal only - not on cert
        tested_by = data.get('testedBy', 'Mick Bartlett')
        timestamp = data.get('timestamp', datetime.now().isoformat())
        photos = data.get('photos', [])
        
        # Service-specific fields
        pipe_material = data.get('pipeMaterial', '')
        pipe_size = data.get('pipeSize', '')
        method = data.get('method', '')
        
        # Closed Pipe fields
        val_flow_before = data.get('valFlowBefore', '')
        cus_flow_before = data.get('cusFlowBefore', '')
        val_flow_after = data.get('valFlowAfter', '')
        cus_flow_after = data.get('cusFlowAfter', '')
        
        # Open Channel fields
        device_type = data.get('deviceType', '')
        range_val = data.get('range', '')
        units = data.get('units', '')
        level_channel_before = data.get('levelChannelBefore', '')
        level_meter_before = data.get('levelMeterBefore', '')
        level_channel_after = data.get('levelChannelAfter', '')
        level_meter_after = data.get('levelMeterAfter', '')
        
        # Loop Test fields
        low_desired = data.get('lowDesired', '')
        low_measured = data.get('lowMeasured', '')
        mid_desired = data.get('midDesired', '')
        mid_measured = data.get('midMeasured', '')
        high_desired = data.get('highDesired', '')
        high_measured = data.get('highMeasured', '')
        
        # Chart Recorder fields
        measurement_type = data.get('measurementType', '')
        meter_before = data.get('meterBefore', '')
        chart_before = data.get('chartBefore', '')
        meter_after = data.get('meterAfter', '')
        chart_after = data.get('chartAfter', '')
        
        # Parse timestamp
        try:
            test_date = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
        except:
            test_date = datetime.now()
        
        date_str = test_date.strftime('%B %d, %Y')
        
        # Create PDF
        buffer = io.BytesIO()
        c = canvas.Canvas(buffer, pagesize=letter)
        width, height = letter
        
        # Logo
        logo_width = 50 * mm
        logo_x = 80
        logo_y = height - 45
        
        try:
            import urllib.request
            logo_url = "https://mickeyrivers.github.io/pcms-mobile-v2/logo.png"
            logo_data = urllib.request.urlopen(logo_url).read()
            logo_buffer = io.BytesIO(logo_data)
            c.drawImage(logo_buffer, logo_x, logo_y, width=logo_width, preserveAspectRatio=True, mask='auto')
        except Exception as e:
            print(f"Logo error: {e}")
            c.setFont("Helvetica-Bold", 16)
            c.setFillColor(NAVY)
            c.drawString(72, height - 50, "YOUR GO-TO FLOW PROS")
        
        # Header
        y = height - 85
        c.setFont("Helvetica-Bold", 18)
        c.setFillColor(NAVY)
        
        title = "STARTUP VERIFICATION" if is_startup else "CALIBRATION VERIFICATION"
        c.drawCentredString(width/2, y, title)
        
        y -= 20
        c.setFont("Helvetica", 10)
        c.setFillColor(NAVY)
        c.drawCentredString(width/2, y, f"Certificate of {service_type} Test")
        
        # Gold line
        y -= 15
        c.setStrokeColor(GOLD)
        c.setLineWidth(2)
        c.line(72, y, width - 72, y)
        
        # Customer info section
        y -= 30
        c.setFont("Helvetica-Bold", 11)
        c.setFillColor(NAVY)
        c.drawString(72, y, "CUSTOMER INFORMATION")
        
        y -= 20
        c.setFont("Helvetica", 10)
        c.setFillColor(HexColor('#333333'))
        
        info_items = [
            ("Customer:", customer),
            ("Location:", location),
            ("Date:", date_str),
        ]
        
        for label, value in info_items:
            c.setFont("Helvetica-Bold", 10)
            c.drawString(72, y, label)
            c.setFont("Helvetica", 10)
            c.drawString(150, y, str(value))
            y -= 15
        
        # Equipment info section
        y -= 15
        c.setFont("Helvetica-Bold", 11)
        c.setFillColor(NAVY)
        c.drawString(72, y, "EQUIPMENT DETAILS")
        
        y -= 20
        c.setFont("Helvetica", 10)
        c.setFillColor(HexColor('#333333'))
        
        equip_items = [
            ("Serial Number:", serial_number),
            ("Manufacturer/Model:", manufacturer),
        ]
        
        if water_type:
            equip_items.append(("Water Type:", water_type))
        if device_type:
            equip_items.append(("Device Type:", device_type))
        
        for label, value in equip_items:
            c.setFont("Helvetica-Bold", 10)
            c.drawString(72, y, label)
            c.setFont("Helvetica", 10)
            c.drawString(180, y, str(value))
            y -= 15
        
        # Test Results section
        y -= 15
        c.setFont("Helvetica-Bold", 11)
        c.setFillColor(NAVY)
        c.drawString(72, y, "TEST RESULTS")
        
        y -= 20
        
        # Draw results table based on service type
        if service_type == 'Closed Pipe':
            # Table header
            c.setFillColor(NAVY)
            c.rect(72, y - 5, width - 144, 20, fill=True)
            c.setFillColor(HexColor('#ffffff'))
            c.setFont("Helvetica-Bold", 9)
            c.drawString(80, y, "Condition")
            c.drawString(200, y, "Validation Flow")
            c.drawString(350, y, "Customer Flow")
            
            y -= 25
            c.setFillColor(HexColor('#333333'))
            c.setFont("Helvetica", 10)
            
            before_label = "Initial" if is_startup else "Before"
            after_label = "Final" if is_startup else "After"
            
            c.drawString(80, y, before_label)
            c.drawString(200, y, str(val_flow_before))
            c.drawString(350, y, str(cus_flow_before))
            
            y -= 18
            c.drawString(80, y, after_label)
            c.drawString(200, y, str(val_flow_after))
            c.drawString(350, y, str(cus_flow_after))
            
        elif service_type == 'Open Channel':
            # Table header
            c.setFillColor(NAVY)
            c.rect(72, y - 5, width - 144, 20, fill=True)
            c.setFillColor(HexColor('#ffffff'))
            c.setFont("Helvetica-Bold", 9)
            c.drawString(80, y, "Condition")
            c.drawString(200, y, "Channel Level")
            c.drawString(350, y, "Meter Level")
            
            y -= 25
            c.setFillColor(HexColor('#333333'))
            c.setFont("Helvetica", 10)
            
            before_label = "Initial" if is_startup else "Before"
            after_label = "Final" if is_startup else "After"
            
            c.drawString(80, y, before_label)
            c.drawString(200, y, str(level_channel_before))
            c.drawString(350, y, str(level_meter_before))
            
            y -= 18
            c.drawString(80, y, after_label)
            c.drawString(200, y, str(level_channel_after))
            c.drawString(350, y, str(level_meter_after))
            
        elif service_type == 'Loop Test':
            # Table header
            c.setFillColor(NAVY)
            c.rect(72, y - 5, width - 144, 20, fill=True)
            c.setFillColor(HexColor('#ffffff'))
            c.setFont("Helvetica-Bold", 9)
            c.drawString(80, y, "Test Point")
            c.drawString(200, y, "Desired")
            c.drawString(350, y, "Measured")
            
            y -= 25
            c.setFillColor(HexColor('#333333'))
            c.setFont("Helvetica", 10)
            
            c.drawString(80, y, "Low (4mA)")
            c.drawString(200, y, str(low_desired))
            c.drawString(350, y, str(low_measured))
            
            y -= 18
            c.drawString(80, y, "Mid (12mA)")
            c.drawString(200, y, str(mid_desired))
            c.drawString(350, y, str(mid_measured))
            
            y -= 18
            c.drawString(80, y, "High (20mA)")
            c.drawString(200, y, str(high_desired))
            c.drawString(350, y, str(high_measured))
            
        elif service_type == 'Chart Recorder':
            # Table header
            c.setFillColor(NAVY)
            c.rect(72, y - 5, width - 144, 20, fill=True)
            c.setFillColor(HexColor('#ffffff'))
            c.setFont("Helvetica-Bold", 9)
            c.drawString(80, y, "Condition")
            c.drawString(200, y, "Meter Reading")
            c.drawString(350, y, "Chart Reading")
            
            y -= 25
            c.setFillColor(HexColor('#333333'))
            c.setFont("Helvetica", 10)
            
            c.drawString(80, y, "Before")
            c.drawString(200, y, str(meter_before))
            c.drawString(350, y, str(chart_before))
            
            y -= 18
            c.drawString(80, y, "After")
            c.drawString(200, y, str(meter_after))
            c.drawString(350, y, str(chart_after))
        
        y -= 30
        
        # Additional info
        if meter_reading:
            c.setFont("Helvetica-Bold", 10)
            c.drawString(72, y, "Meter Reading:")
            c.setFont("Helvetica", 10)
            c.drawString(160, y, meter_reading)
            y -= 15
            
        if calibration:
            c.setFont("Helvetica-Bold", 10)
            c.drawString(72, y, "Calibration:")
            c.setFont("Helvetica", 10)
            c.drawString(160, y, calibration)
            y -= 15
            
        if programming:
            c.setFont("Helvetica-Bold", 10)
            c.drawString(72, y, "Programming:")
            c.setFont("Helvetica", 10)
            c.drawString(160, y, programming)
            y -= 15
        
        # Notes (only regular notes, not tech notes)
        if notes:
            y -= 10
            c.setFont("Helvetica-Bold", 10)
            c.drawString(72, y, "Notes:")
            y -= 15
            c.setFont("Helvetica", 9)
            # Word wrap notes
            words = notes.split()
            line = ""
            for word in words:
                if c.stringWidth(line + " " + word, "Helvetica", 9) < width - 144:
                    line = line + " " + word if line else word
                else:
                    c.drawString(72, y, line)
                    y -= 12
                    line = word
            if line:
                c.drawString(72, y, line)
                y -= 12
        
        # Footer
        y -= 20
        c.setFont("Helvetica-Bold", 10)
        c.drawString(72, y, "Tested By:")
        c.setFont("Helvetica", 10)
        c.drawString(140, y, tested_by)
        
        y -= 25
        c.setStrokeColor(GOLD)
        c.setLineWidth(1)
        c.line(72, y, width - 72, y)
        
        y -= 15
        c.setFont("Helvetica", 8)
        c.setFillColor(HexColor('#666666'))
        c.drawCentredString(width/2, y, "YOUR GO-TO FLOW PROS | Calibration & Testing Services")
        y -= 10
        c.drawCentredString(width/2, y, "www.pcms-services.com | info@pcms-services.com")
        
        # Photos section - centered with reduced gap
        if photos and len(photos) > 0:
            valid_photos = [p for p in photos if p]
            if valid_photos:
                y -= 15  # Reduced gap
                
                # Calculate available space
                available_height = y - 30  # Leave margin at bottom
                
                if available_height > 25 * mm:  # Only add photos if enough space
                    num_photos = len(valid_photos)
                    
                    # Calculate photo dimensions
                    max_photo_height = min(45 * mm, available_height)  # Reduced max height
                    photo_width = 45 * mm
                    gap = 5 * mm  # Small gap between photos
                    
                    # Calculate total width and starting x for centering
                    total_width = (num_photos * photo_width) + ((num_photos - 1) * gap)
                    start_x = (width - total_width) / 2
                    
                    for i, photo_data in enumerate(valid_photos):
                        try:
                            img_buffer = fix_image_orientation(photo_data)
                            x_pos = start_x + (i * (photo_width + gap))
                            c.drawImage(img_buffer, x_pos, y - max_photo_height, 
                                       width=photo_width, height=max_photo_height,
                                       preserveAspectRatio=True, mask='auto')
                        except Exception as e:
                            print(f"Error adding photo {i}: {e}")
        
        c.save()
        
        # Upload to Dropbox
        pdf_data = buffer.getvalue()
        
        # Create filename
        safe_customer = "".join(c for c in customer if c.isalnum() or c in (' ', '-', '_')).rstrip()
        safe_serial = "".join(c for c in serial_number if c.isalnum() or c in (' ', '-', '_')).rstrip()
        date_folder = test_date.strftime('%Y-%m')
        filename = f"{safe_serial}_{test_date.strftime('%Y%m%d')}.pdf"
        dropbox_path = f"/PCMS Certificates/{safe_customer}/{date_folder}/{filename}"
        
        # Also save raw data JSON (includes techNotes)
        raw_data = {
            **data,
            'generated_at': datetime.now().isoformat(),
            'pdf_path': dropbox_path
        }
        raw_filename = f"{safe_serial}_{test_date.strftime('%Y%m%d')}_data.json"
        raw_path = f"/PCMS Certificates/{safe_customer}/{date_folder}/{raw_filename}"
        
        try:
            dbx = dropbox.Dropbox(DROPBOX_ACCESS_TOKEN)
            
            # Upload PDF
            dbx.files_upload(
                pdf_data,
                dropbox_path,
                mode=dropbox.files.WriteMode.overwrite
            )
            
            # Upload raw data JSON
            dbx.files_upload(
                json.dumps(raw_data, indent=2).encode('utf-8'),
                raw_path,
                mode=dropbox.files.WriteMode.overwrite
            )
            
            return jsonify({
                'success': True,
                'message': 'Certificate generated and uploaded',
                'dropbox_path': dropbox_path,
                'raw_data_path': raw_path
            }), 200, headers
            
        except Exception as e:
            return jsonify({
                'success': False,
                'error': f'Dropbox upload failed: {str(e)}',
                'pdf_generated': True
            }), 500, headers
            
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500, headers
